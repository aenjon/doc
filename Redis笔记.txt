==================================================  String  =========================================================
Redis Setnx 命令:SETNX KEY_NAME VALUE
//SET if Not eXists，设置成功，返回 1 。 设置失败，返回 0 。

Redis Setex 命令:SETEX KEY_NAME TIMEOUT VALUE
//Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。设置成功时返回 OK 。

Redis Expire 命令:Expire KEY_NAME TIME_IN_SECONDS
//Redis Expire 命令用于设置 key 的过期时间。设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0 。

Redis Llen 命令:LLEN KEY_NAME
//Redis Llen 命令用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。

Redis Get 命令:GET KEY_NAME
//返回 key 的值，如果 key 不存在时，返回 nil。 如果 key 不是字符串类型，那么返回一个错误。

Redis SET 命令:SET KEY_NAME VALUE
//Redis SET 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。SET 在设置操作成功完成时返回 OK 。

Redis Hset 命令: HSET KEY_NAME FIELD VALUE 
//如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。

Redis Hget 命令:HGET KEY_NAME FIELD_NAME 
//返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。

Redis Hdel 命令:HDEL KEY_NAME FIELD1.. FIELDN 
//用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。返回被成功删除字段的数量，不包括被忽略的字段。

Redis DEL 命令:DEL KEY_NAME
//Redis DEL 命令用于删除已存在的键。不存在的 key 会被忽略。被删除 key 的数量。

Redis Hexists 命令:HEXISTS KEY_NAME FIELD_NAME 
//Redis Hexists 命令用于查看哈希表的指定字段是否存在。如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。

Redis Keys 命令：KEYS PATTERN
//Redis Keys 命令用于查找所有符合给定模式 pattern 的 key 。

Redis Incr 命令:INCR KEY_NAME 
Redis Incr 命令将 key 中储存的数字值增一。
如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
返回值
执行 INCR 命令之后 key 的值。
本操作的值限制在 64 位(bit)有符号数字表示之内。

Redis Incrby 命令
INCRBY KEY_NAME INCR_AMOUNT
Redis Incrby 命令将 key 中储存的数字加上指定的增量值。
如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。
如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。(error) ERR value is not an integer or out of range
本操作的值限制在 64 位(bit)有符号数字表示之内。
返回值
加上指定的增量值之后， key 的值。



==================================================  LIST  =========================================================
Redis Rpop 命令:RPOP KEY_NAME 
Redis Rpop 命令用于移除并返回列表的最后一个元素。
返回值:列表的最后一个元素。 当列表不存在时，返回 nil 。

Redis Lrange 命令: LRANGE KEY_NAME START END
Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 
其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 
你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
返回一个列表，包含指定区间内的元素。

Redis Lpush 命令: LPUSH KEY_NAME VALUE1.. VALUEN
Redis Lpush 命令将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。
返回值:执行 LPUSH 命令后，列表的长度。



==================================================  Redis事务  =========================================================
Redis 事务
Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：
事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
一个事务从开始到执行会经历以下三个阶段：开始事务。命令入队。执行事务。

举个例子，使用redis-cli连接redis，然后在命令行工具中输入如下命令：

127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set url http://qifuguang.me
QUEUED
127.0.0.1:6379> set title winwill2012
QUEUED
127.0.0.1:6379> set desc java
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK
3) OK

从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，
这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。

事务中的错误
使用事务时可能会遇上以下两种错误：
事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。
命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。

对于发生在 EXEC 执行之前的错误，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。
至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。

使用 check-and-set 操作实现乐观锁
WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。
被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。

Redis Watch 命令：Watch key1 key2 key3 ...
Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
返回值总是返回 OK 。

Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视。UNWATCH 

Redis Multi 命令:Multi
Redis Multi 命令用于标记一个事务块的开始。
事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。
总是返回 OK 。

有了 WATCH ， 我们就可以轻松地解决这类问题了：
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。
这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。
WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。
当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。
另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。
使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。
 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。

Redis Exec 命令用于执行所有事务块内的命令。EXEC 命令负责触发并执行事务中的所有命令：
如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。
另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

Redis Discard 命令:DISCARD
Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。
总是返回 OK 。